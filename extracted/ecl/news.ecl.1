PRINT('
Feb 26, 1980
	BT has had slight changes.  BT\\DEPTH works like "..."
for limiting print depth for most things.  Default is 3, but will
work rather differently when UNPARSFM is present, due to different
rules for depth there (more will be shown.)  The main reason
for changing BT was to allow its use with CI, to avoid extraneous
printout in the main user path.
');
PRINT('
6-28-79
	The BUFPAGE field in the FHB has been replaced by two REFs
to accomodate full duplex devices.  Input buffers are pointed to by
INPAGE and output buffers by OUTPAGE.  Pseudofiles have the same
REF in both spots.  Naughty users who knew about BUFPAGE are
warned that code referencing it must be reexamined!  In addition,
the FHB size has changed, so compiled code which generates a FHB
using CONST, ALLOC, or CONSTRUCT must be recompiled or the garbage
collector will get you.

	The DDB has also had a USER:REF field added to facilitate
user extensions which would rather hang things off the
DDB rather than off the property list of the SBLK
belonging to its ATOM.  NOTE!!! that LOADB and DUMPB
will not currently handle data stored here!!!

');
PRINT('
3-31-78
   A new function has been added to UP.BIN:
UNPARSELIST(Statements:FORM,P:PORT,Depth:INT,Indent:INT;
	    SEQ(FORM))
Prints the statement list given as its first argument on port P,
using Depth as the depth level at which to abbreviate (" ... ")
and using Indent as an indication of starting column at the time
of the call. (These are analogous to the arguments taken by
UNPARSFM; the difference is that UNPARSELIST expects a
list of zero or more forms, not just a single form.) For example,
UNPARSELIST(L,P,1,10) will unparse the elements of list L on
port P, suppressing the contents of blocks below the first level,
and assuming the "print head" to be in column 10 at the
time of call. Thus, no extra indentation will be added to the
first line, but subsequent lines will be indented to correspond
with this initial head position.
   UNPARSELIST inserts a semicolon and starts a new line between
the members of Statements, but like UNPARSFM it adds neither a
semicolon nor a carriage return after the last statement.
   UNPARSELIST is also capable of producing "numbered ellipses" instead
of the usual "..." used to abbreviate suppressed passages, and in this
mode, it will return a SEQ(FORM) containing the sublists of the input
statement list that have been omitted during printing. This mode is
enabled using the parameter setting function POKE\UP.  The POKE\UP
keyword COUNTELLIPSES is set to TRUE to enable numbered
ellipses, and the parameters CASEOP and LISTOP are set to symbols
that are to be used for abbreviating omitted lists. For instance:
->POKE\UP(COUNTELLIPSES,TRUE)$
FALSE
->POKE\UP(LISTOP,"??");
->POKE\UP(CASEOP,"&&");
->L <- <CASE[N] [1]=>1; TRUE=>N*F(N-1) END + [)P=>X;Y(]>;
->S <- UNPARSELIST(L,NIL,1);
CASE[N] &&1 END + [) ??2 (]
->
POKE\UP returns the original value of the parameter being replaced.
After this series of commands, S will be a sequence of two forms: the
CASE statement list corresponding to &&1 and the ordinary statement list
corresponding to ??2.  If proper parsing fixities are given to the operators
?? and &&, the abbreviation produced by UNPARSELIST can be reparsed.
In this case, PREFIX("??") and SYNFIX("&&","=>") are the appropriate
commands. ("=> expression" is a legal case statement whose internal
form is (=> ([] NIL NIL) expression).)
');


PRINT('
11-11-78
   SAVE AND RESTORE NOW RETURN A BOOL.  SINCE RESTORE RESTORES THE
	SAVED ENVIRONMENT, IT%'S APPARENT EXIT IS FROM THE INVOCATION
	OF SAVE THAT SAVED THE ENVIRONMENT.  SAVE RETURNS FALSE
	WHEN SAVING THE ENVIRONMENT, BUT TRUE WHEN THE ENVIRONMENT
	HAS JUST BEEN RESTORED.  THIS FEATURE MAY BE EMPLOYED
	TO IMPLEMENT A CHECKPOINT-RESTART FACILITY. THE USER
	IS, OF COURSE, RESPONSIBLE FOR SAVING THE STATUS OF
	ANY OPEN FILES (AND THEIR POSITION, USING SETBYTE) AND
	CLOSEING THEM BEFORE CALLING SAVE.
');

PRINT('
04-11-77
   EVAL WILL ACCEPT SYNONYMS FOR EXPRS. FOR EXAMPLE, IF
	SYNFIX("RTN", "EXPR");
	"RTN".TLB <-  "EXPR".TLB;
	A <- RTN(I: INT; INT) I*I + 7;
ARE DONE, THEN A(5) WILL EXECUTE JUST AS IF IT WERE AN EXPR.
   TWO NEW IO ROUTINES, DUMPIN(OBJ:ANY, P:PORT) AND
DUMPOUT(OBJ:ANY, P:PORT), WILL HANDLE LENGTH RESOLVED,
NON-POINTER CONTAINING OBJECTS ON A PORT OPENED IN DUMP MODE.
THESE ROUTINES ARE MACHINE DEPENDENT AND SEEK TO TAKE ADVANTAGE
OF THE SPEED OF DUMP MODE IO TO SPECIAL DEVICES. THE PORT SHOULD
BE OPENED WITH "DUMP" AS THE THIRD ARGUMENT TO OPEN. IF THE
OBJECT IS BAD, A MISCELLANEOUS ERROR, NUMBER 2133, WILL OCCUR WITH
T\2 THE OBJECT AND T\3 THE PORT.  IF THE PORT IS BAD, A PORT ERROR,
NUMBER 16, WILL OCCUR WITH T\2 THE PORT AND T\3 THE OBJECT.
   ARPA.BIN SHOULD NOW WORK.  IN ADDITION, IF ONE HAS THE CORRECT
PRIVILEGES, 32 BIT ABSOLUTE LOCAL SOCKET NUMBERS MAY BE SPECIFIED BY
SUFFIXING THE LOCAL SOCKET NUMBER WITH A HASHMARK, "#". FOREIGN SOCKETS
ARE ALWAYS ABSOLUTE, AND MAY NOW BE UP TO 32 BITS LONG. THE FORMAT IS
	"NET:<LS>.<HOST NAME OR NUM>-<FS>"
FOR EXAMPE, OPEN("NET:1") WILL SET UP A LISTEN ON LOCAL SOCKET
1 RELATIVE TO THE USERS PROGRAMMER NUMBER. OPEN("NET:1#")
WOULD SET UP A LISTEN WITH ABSOLUTE LOCAL SOCKET NUMBER 1.  SINCE THIS
IS THE SYSTEMS LOGGER SOCKET, IT WOULD BE A GOOD IDEA NOT TO DO
THIS UNLESS ONE IS PREPARED TO BE A LOGGER. USE WITH CAUTION!
   FURTHER NEW ARPA FEATURES.  IF "ICP:: ..." IS USED TO
SPECIFY THE DEVICE, A DUPLEX CONNECTION ON ONE IMP IS ATTEMPTED.
THE PORT OF OPPOSITE PARITY (E.G. IF THE OPEN SPECIFIED "IN", THE
OUTPUT PORT) WILL BE RETURNED IN THE USER FIELD OF THE PORT.  THE
USE OF THE USER FIELD OF A PORT IS THUS, FOR THE MOMENT, RESTRICTED.
IF THE USER FIELD OF ONE PORT CONTAINS AN FHB WHOSE USER FIELD
POINTS BACK TO THE FIRST PORT, THE IO ROUTINES ASSUME THAT THESE
TWO LINKED PORTS CONSTITUTE AN ARPA ICP CONNECTION. OTHERWISE
THE USER FIELD MAY BE USED AS ONE PLEASES.
');
PRINT('
10-14-76
POKE(TTYFAST,TRUE) WILL CAUSE TTY INPUT TO BE IN CHAR RATHER THAN
LINE MODE.
PEEK(ECLDIR) WILL NOW RETURN THE SUPER SYMBOL ASSOCIATED WITH THE
SIMULATED DEVICE ECL:. IF NIL IS RETURNED, THE DEVICE REFERS TO SYS:.

THE ECL GRAMMAR HAS BEEN CHANGED TO ALLOW EITHER ANY FORM OR A
PARENTHESIZED FORM WHERE IDS WERE FORMERLY REQUIRED. THIS CHANGE WAS
MADE TO EASE THE ENTRY OF EDITING PATTERNS AND CODE IN MADE UP
LANGUAGES WHICH WILL BE SPECIALLY INTERPRETED WHILE STILL USING THE
CURRENT PARSER.  ANY ATTEMPT TO RUN SUCH CODE WILL RESULT IN AN
EXECUTION ERROR:
FORM FOUND WHERE ID WAS EXPECTED
(MISCELANEOUS-2132) WITH T\2 CONTAINING THE OFFENDING FORM.

IT IS NOW POSSIBLE TO SYNFIX A USER SYMBOL TO THE FOLLOWING
ELEMENTS OF THE GRAMMAR AND HAVE THEM APPEAR IN THE PARSER
OUTPUT: BEGIN, DECL, EXPR, STRUCT, PROC, CASE, FOR, REPEAT,
CONST, AND ALLOC. IN THE CASE OF PARALLEL DECLS, THE FIRST
DECL SYNONYM REPRESENTS ANY FOLLOWING DECLS. IN THE CASE OF
REPEAT SYNONYMS, THE REPEAT SYNONYM IS CARRIED OUT TO THE BEGINNING
OF THE LIST STRUCTURE PRODUCED WHERE IT REPLACES THE "FOR" NORMALLY
PLACED THERE.  THUS IF DO WHERE SYNFIXED WITH REPEAT,
FOR I TO 10 DO ... END
WOULD PARSE AS
(DO FOR I TO 10 DO ...)
AND IF DO WERE BOUND TO A PROCEDURE TAKING A FORM LISTED, THAT
PROCEDURE COULD INTERPRET THE REMAINING LIST STRUCTURE.
');



PRINT('(9-24-76)
A NEW VERSION OF EDITF HAS BEEN INSTALLED.  UNTIL COMPLETE DOCUMENTATION
IS READY, A PROTOCOL EXHIBITING THE NEW FEATURES CAN BE FOUND IN
DOC:EDITF.PRO
');
PRINT('
9-14-76
REVIVEPORT(OLD,NEW) WILL REVIVE THE OLD PORT AT END OF FILE
IN SUCH A WAY THAT CONT() AFTER EOF WILL SUCCEED.
COMMAND\PRINT IS THE NAME OF THE ROUTINE USED FOR ALT($) PRINTING
BY THE ECL INTERPRETER.  IT IS ORIGINALLY BOUND TO PRINT.
REPEAT IS NOW IN THE GRAMMAR AS A FORM MEANING THAT STATEMENTS
SUCH AS  FOR I TO 10 REPEAT ... END AND TRUE WILL PARSE.
PORT\STR NOW RETURNS THE PPN AS PART OF THE FILE NAME.
IF PAR\E IS A FORM, THEN IT IS EVALED IN CASE OF PARSE
ERRORS. T\2 IS THE INPUT PORT. T\3 IS THE OUTPUT PORT.
T\4 IS THE BYTE COUNT OF THE FIRST CHAR OF THE
LEXEME AT WHICH THE PARSER DETECTED THE ERROR.  BY USE
OF SETBYTE AND RANDOM ACCESS IO, THE CONTEXT OF THE ERROR MAY
BE DISPLAYED. CONT(FALSE) FROM THIS TRAP WILL RESULT IN THE
CURRENT ERROR MSG. CONT(TRUE) WILL SUPPRESS IT.
');
PRINT('
8-10-76
NEW ROUTINES:
CONS(FORM,FORM)	= ALLOC(DTPR OF F1, F2)
MAKEFORM(ANYOBJ) RETURNS ANYOBJ AS A FORM.
LISTCOPY(F1) COPIES THE LIST POINTED TO BY F1.
LISTEQUAL(F1, F2) DOES LIST EQUALITY DOWN TO VALS OF TERMINAL
	REFS.
LISTAPPEND(F1, F2) COPIES THE TOP LEVEL OF F1 AND APPENDS F2.
LIST( ... )  FORMS A LIST FROM THE EVALUATION OF EACH ELEMENT OF
	ITS ORGINAL ARGUMENT LIST.
LISTSUBST(NEWF, OLDF, F) WILL REPLACE ALL OCCURRENCES OF OLDF AS
	A CAR IN F WITH NEWF.
SYNFIX(S1,S2) WILL GIVE S1 THE PARSING PROPERTIES OF S2.  IN EFFECT
	THIS ROUTINE COPIES THE SINFO, CONSTF, AND RMATCH FIELDS OF
	SYMBOL S2 INTO S1%'S. IT RETURNS THE ORIG. SBLK FIELD OF S1.
');
PRINT('
7-16-76
The EXEC Reference Guide is available as DOC:EXEC.DOC
');
PRINT('
6-15-76
ALL IO ROUTINES WHICH USED TO REQUIRE A SYMBOLIC PORT
WILL NOW TAKE A BINARY PORT WITH BYTESIZE 7.

SETBYTE NOW WORKS ON ALL FILES, NOT JUST RANDOM OR UPDATE FILES.
SETBYTE(PORT,N) RETURNS THE BYTE WHICH WILL BE NEXT READ OR WRITTEN
IF N GE 0, THE SIZE OF THE FILE IN BYTES IF N LT 0, AND PORT IS
NOT RANDOM OR UPDATE.

RENAME TAKES AN OPTIONAL THIRD ARGUMENT WHICH IS AN OVERRIDE
SUPER SYMBOL.  ADDITIONALLY, IT NOW USES THE GLOBAL
IO DEFAULT SUPERSYMBOL TO CREATE BOTH THE OLD FILE NAME AND THE
NEW FILENAME.

* IN THE NAME OR EXTENSION FIELD OF A SUPERSYMBOL MEANS DON%T
CHANGE WHATEVER THE NAME OR EXTENSION CURRENTLY IS.

ECL: IS NOW A PSEUDODEVICE WHICH WILL WORK ON TOPS10 AND TENEX
SYSTEMS.  REFERENCES TO THE COMPILER, EDITOR, UNPARSER, AND OTHER
SUCH SYSTEM FILES SHOULD NOW BE MADE USING ECL: RATHER THAN SYS:.

POKE(EXIT,N) WILL EXIT TO THE MONITOR WITHOUT RELEASING FILES
(A SOFT EXIT) IF N GT 0.  IT WILL RELEASE FILES AND BE UNCONTINUABLE IF
N = 0 (HARD EXIT) AND ADDITIONALLY WILL CLEAR TTY TYPEAHEAD IF N LT 0.
PEEK(HELP) WILL RETURN AS A STRING A LIST OF CURRENT PEEK, POKE
KEYWORDS.

PEEK(PPN) WILL RETURN THE PROJECT, PROGRAMMER NUMBER OF THE JOB RUNNING
ECL.

PEEK(IOCHAN,N) WILL RETURN THE PORT ASSOCIATED WITH CHANNEL N(0<N<16).

POKE(RUN,SS,SA) WILL DO A RUN UUO ON THE FILE OBTAINED FROM THE SUPER
SYMBOL SS WITH STARTING ADDRESS INCREMENT SA.

POKE(ECLDIR,N) WILL SET THE PPN FOR ECL:
');
PRINT('
3-30-76
...  (THE POINTER LEVEL FOR PRINT SUPPRESSION) NOW HAS AN ADDITIONAL
MEANING.  IT ALSO LIMITS THE NUMBER OF COMPONENTS PRINTED OF COMPOUND
OBJECTS.  THIS IS PARTICULARLY USEFUL IN LIMITING THE SIZE OF BT AND
NSBT PRINTOUTS.

BT HAS AN ADDITIONAL FUNCTION, NSBT(START, NUMBER) WHICH DISPLAYS NAME
STACK ENTRIES FROM START (HIGH NS RECORD NUMBER) TO START  MINUS THE
ABSOLUTE VALUE OF NUMBER. IF NUMBER IS NEGATIVE, NOT ONLY IS
THE NAME AND MODE PRINTED, BUT ALSO THE VALUE.  NSBT() WILL SHOW
THE WHOLE NAME STACK WITH RECORD NUMBERS, NAME, AND MODE.

THE TRAP HANDLER HAS BEEN REWRITTEN SO THAT IT IS POSSIBLE TO
TRAP ON ALL ERRORS. SEE SYS: ECLTRP.DOC FOR DETAILS.
');
PRINT('
3-28-76
PRINT AND ASSOCIATED ROUTINES HAVE BEEN COMPLETELY REWRITTEN.
THE ENTIRE UR CHAIN OF EXTENDED MODES IS NOW PRINTED UNTIL A
USER PRINT FUNCTION OR A NON-EXTENDED MODE IS REACHED.

INOBJ,OUTOBJ, AND PACKOBJ NOW TRAP ON POINTER OBJECTS WITH THE
FOLLOWING PARAMETERS:
T\2	THE OFFENDING POINTER OBJECT
T\3	THE PORT (OR AN INTERNAL BUFFER FOR PACKOBJ)
T\4	"IN" FOR INOBJ, "OUT" FOR OUTOBJ. (FIRST PART OF PACKOBJ
	IS "OUT" TO THE INTERNAL BUFFER. SECOND PART IS "IN").
OBJ\E	FORM TO SET INORDER TO TRAP ON THIS EXCEPTION
THIS EXCEPTION IS CONTINUABLE WITH A SUBSTITUTE OBJECT.

MARK RECORDS WITH THE PROPERTY  OF ACTING LIKE CONTROL FLOORS
THROUGH WHICH CONTROL CAN NOT PASS ARE NOW AVAILABLE. IF CONTROL
(VIA RETURN, RETBRK, OR RESET) ATTEMPTS TO PASS A MARK RECORD
WITH ID "RETURN\E" AND IF RETURN\E EVALUATED IN
THE ENVIRONMENT OF THAT MARK RECORD IS A FORM -- THEN THE FORM
IS EVALUATED.  IF THE RESULT OF THE FORM IS "RETURN\E", THE FLOOR
IS PASSED THROUGH. IF THE RESULT IS ANY OTHER OBJECT, THE MARK RECORD
IS EXITED JUST AS THOUGH THERE HAD BEEN AN EXPLICIT RETURN TO
THAT MARK RECORD.  EXPLICIT RETURNS AND GOING THROUGH THE MARK
RECORD BY DROPPING OUT OF A MARKED FORM DO NOT INVOKE THE TRAP.
ALSO, IF RETURN\E WAS NOT A FORM AT THE TIME THE MARK WAS MADE,
AN ERROR(CLASS = RETURN, SUBCLASS = 1701,1702,170 FOR RETURN,
RETBRK, RESET) IS INVOKED.
');

PRINT('
29-FEB-76
A new compiler has been installed. The files that used to
be called PASS1, PASS2, PASS3, AND SCAN are now ANALYZ,
CODE, ASSEMB, and SCANF, respectively.  From the user%'s
viewpoint, the only major change is in the SCANning of files
to prepare them for compilation.  Instead of loading and calling
SCAN as described in the Manual, one now uses EDITF, a file
handling extension of the ECL Editor.  Want to see
an example of the new scanning scheme? (Y or N)');
LEX(OPEN("TTY:")) = "Y" ->
PRINT('
 1)  .R ECL
 2)  ECL(1-15-76) LOAD"SYS:NEWS"
 3)  
 4)  ->LOADB "SYS:EDITF";
 5)  [SYS:EDIT.BIN]
 6)  EDIT  [2.3.1976]
 7)  [SYS:UP.BIN]
 8)  
 9)  ->SAVEMINE <- SCANF("MINE");
10)  [MINE]
11)  [SCANF.BIN]
12)  PROC2
13)  PROC1		KONST
14)  [EDIT COMPILER INPUTS, THEN "RESCAN" OR "EXIT"]
15)  * ... <- 1;
16)  * S(VAR);
17)  * $
18)  VAR;
19)  * UP$
20)  CONST\NAMES <- QL(VAR);
21)  * CS(VAR)$
22)  SHARED\NAMES <- QL(VAR);
23)  * S(MDKN\PAIRS);
24)  * $
25)  MDKN\PAIRS <- QL(KONST(INT));
26)  * EXIT;
27)  [MINE]
28)  * ZJ;
29)  * T-2;
30)  VAR _ 1.23E2;
31)  PROC2 <- EXPR() [) DECL KONST:INT; PROC1() (];
32)  * INSERT\SCAN;
33)  * T-2;
34)  LNK\NAME <- "MINE.LNK";
35)  COMPILE\MINE = TRUE ->
36)   BEGIN ... END;
37)  * EXIT;
38)  [MINE]
39)  
40)  ->... <- 2;
41)  
42)  ->UNPARSE(SAVEMINE);
43)  
44)  BEGIN
45)   PROC1 <- EXPR() VAR _ VAR + KONST;
46)   VAR _ 1.23E2;
47)   PROC2 <- EXPR() [) DECL KONST:INT; PROC1() (];
48)   SCAN\TERMINATE = NOTHING +> SCAN\TERMINATE();
49)   INIT\FORM <- QL();
50)   COMPILE\MINE = TRUE +>
51)    [) MD(LDPORT) = PORT -> CLOSE(LDPORT); EVAL(INIT\FORM) (];
52)   ROUTINE\NAMES <- QL(PROC2, PROC1);
53)   SHARE\ROUTINES <- TRUE;
54)   SHARED\NAMES <- QL(VAR);
55)   CONST\NAMES <- QL();
56)   MDKN\PAIRS <- QL(KONST(INT));
57)   EXTENDED\MODES <- QL();
58)   SMACRO\PAIRS <- QL();
59)   SMACRO\NAMES <- QL();
60)   CMACRO\PAIRS <- QL();
61)   PRELUDE\FORM <- QL();
62)   POSTLUDE\FORM <- QL();
63)   PACKAGE\NAMES <- QL();
64)   BIN\NAME <- "MINE.BIN";
65)   BIG\NAME <- "MINE.BIG";
66)   LNK\NAME <- "MINE.LNK";
67)   COMPILE\MINE = TRUE ->
68)    BEGIN ... END;
69)  END;
70)  
71)  ->SCANF("MINE",SAVEMINE);
72)  PROC2
73)  PROC1		KONST
74)  [EDIT COMPILER INPUTS, THEN "RESCAN" OR "EXIT"]
75)  * S(PACKAGE\NAMES);
76)  * $
77)  PACKAGE\NAMES <- QL();
78)  * ADD(PROC1,VAR)$
79)  PACKAGE\NAMES <- QL(PROC1, VAR);
80)  * EXIT;
81)  [MINE]
82)  * S(SCAN\TERMINATE);
83)  * $
84)  SCAN\TERMINATE = NOTHING +> SCAN\TERMINATE();
85)  * K+100;
86)  * INSERT\SCAN;
87)  * BS(**PACKAGE\NAMES);
88)  * $
89)  PACKAGE\NAMES <- QL(PROC1, VAR);
90)  * EXIT;
91)  [MINE]

Notes:
(4-7) On TENEX systems, EDITF, EDIT, and UP are already loaded.

(9) SCANF%'s argument is the name of the file to be scanned.  Its
result is a BEGIN-block in list structure.  It can be UNPARSEd, EDITed,
or scanned again.  See line 71.

(14) After scanning, the Editor is used to alter the tentative
compiler input lists and parameters.

(26) The first  EXIT  causes the Editor to be  applied to the (list
representation of) the file itself.

(28-36) The attention pointer is moved to the end of the file, and
the compilation control code is inserted with the command  INSERT\SCAN.

(37) On EXIT, a new copy of the source file is UNPARSEd to DSK.

(48-68) These lines have been inserted to control compilation.
Placed at the end of the file, they are inactive unless COMPILE\MINE
is bound to TRUE before loading.

(71) To rescan without rereading the source file, the list-structure
copy of the file is passed as a second argument to SCANF.

(82-85) When a file has been scanned previously, the old compilation
control commands must be deleted before the new ones are inserted.
');

PRINT('
29 JAN 76
A NOTE DESCRIBING RECENT CHANGES TO THE ECL EDITOR IS
AVAILABLE FROM STEVEN GERMAN.
');

PRINT('
14 JAN 76
PACKOBJ(OBJ1,OBJ2) WILL PACK THE DATA BITS OF OBJ2 INTO
THE DATA BITS OF OBJ1 COMPONENT BY COMPONENT. IT IS
ANALOGOUS TO AN OUTOBJ(OBJ2,P) FOLLOWED BY AN INOBJ(OBJ1,P)
BUT WITH NO EOF PROBLEMS AND MUCH MORE SPEED. OBJ1 AND
OBJ2 MUST BE POINTER FREE.


PROTECTIONS MAY NOW BE GIVEN IN FILE SUPERSYMBOLS BETWEEN
SLASHES. FOR EXAMPLE RENAME("FOO.FUM/157/","FOO.FUM") OR
OPEN("FEE.ECL/077/","OUT").

PEEK(JOBNUMBER) RETURNS ONES JOBNUMBER. PEEK(SYSDATE) RETURNS
THE DATE AND TIME OF THE ECL SYSTEM CREATION AS AN INTEGER
WITH THE LEFT 18 BITS BEING THE TIME SINCE MIDNIGHT IN MILLISECS,
AND THE RIGHT 18 BITS BEING THE DATE IN STANDARD DEC 15 BIT FORMAT.

LENGTH NOW ONLY DEREFERENCES ONCE. VECTOR(0,X) IS ILLEGAL.
');

PRINT('
30 OCT 75
INOBJ AND OUTOBJ WILL NOW HANDLE ANY NON-POINTER CONTAINING
OBJECT, NOT JUST BASICS AND ROWS OF BASICS.

A NEW PARSER IS NOW FULLY OPERATIONAL WITH THE ADDITION
OF A NEW PARSE WINDOW.
');

PRINT('
8 AUG 75
PLEASE READ THE FILE SYS:ECLNEW.DOC FOR INFORMATION ON
NEW ERROR HANDLING, I\O, AND PEEK OPTIONS.
PLEASE UNPARSE ALL YOUR CURRENT FILES BY SEPTEMBER 1975
SO THAT THEY WILL BE COMPATIBLE WITH A CHANGE IN THE PARSER.
STATMENTS OF THE FORM
NOT  (A_B).FLAG;
WILL BE PARSED AT THAT TIME AS (NOT(A_B)).FLAG.
THE UNPARSER WILL CONVERT SUCH A STATEMENT TO
NOT((A_B).FLAG) WHICH IS THE CURRENT INTERPRETATION.
');
   